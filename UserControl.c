#pragma config(Sensor, dgtl1,  right,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  left,           sensorQuadEncoder)
#pragma config(Motor,  port1,           backRight,     tmotorVex269_HBridge, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port2,           backLeft,      tmotorVex269_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port3,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           claw,          tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           frontRight,    tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port10,          frontLeft,     tmotorVex269_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	while (true)
	{

		// This is the main execution loop for the user control program. Each time through the loop
		// your program should update motor + servo values based on feedback from the joysticks.
		// Based on what wheels are installed, change the program between regular and mecanum wheels

		/*frontRightValue = 0;
		backRightValue = 0;
		frontLeftValue = 0;
		backLeftValue = 0;

		if (abs(vexRT[Ch2]) > 10)
		{
				frontRightValue = vexRT[Ch2];
				backRightValue = vexRT[Ch2];
		}
		if (abs(vexRT[Ch3]) > 10)
		{
				frontLeftValue = vexRT[Ch3];
				backLeftValue = vexRT[Ch3];
		}
		if (abs(vexRT[Ch2Xmtr2]) > 10)
		{
				frontRightValue = vexRT[Ch2Xmtr2];
				backRightValue = vexRT[Ch2Xmtr2];
		}
		if (abs(vexRT[Ch3Xmtr2]) > 10)
		{
				frontLeftValue = vexRT[Ch3Xmtr2];
				backLeftValue = vexRT[Ch3Xmtr2];
		}

		motor[frontRight] = frontRightValue;
		motor[backRight] = backRightValue;
		motor[frontLeft] = frontLeftValue;
		motor[backLeft] = backLeftValue;*/

		// Under here is the code for mecanum wheels
		//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	  int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;

    //Create "deadzone" for Y1/Ch3
    if (abs(vexRT[Ch3]) > threshold)
      Y1 = vexRT[Ch3];
    else if (abs(vexRT[Ch3Xmtr2]) > threshold)
    	Y1 = vexRT[Ch3Xmtr2];
    else
      Y1 = 0;
    //Create "deadzone" for X1/Ch4
    if (abs(vexRT[Ch4]) > threshold)
      X1 = vexRT[Ch4];
    else if (abs(vexRT[Ch4Xmtr2]) > threshold)
    	X1 = vexRT[Ch4Xmtr2];
    else
      X1 = 0;
    //Create "deadzone" for X2/Ch1
    if (abs(vexRT[Ch1]) > threshold)
      X2 = vexRT[Ch1];
    else if (abs(vexRT[Ch1Xmtr2]) > threshold)
    	X2 = vexRT[Ch1Xmtr2];
    else
      X2 = 0;

    //Remote Control Commands
    motor[frontRight] = Y1 - X2 - X1;
    motor[backRight] =  Y1 - X2 + X1;
    motor[frontLeft] = Y1 + X2 + X1;
    motor[backLeft] =  Y1 + X2 - X1;

    //Arm Controls
    if (vexRT[Btn5D] == 1 || vexRT[Btn5DXmtr2] == 1)
    	motor[arm] = 127;
   	else if (vexRT[Btn5U] == 1 || vexRT[Btn5UXmtr2] == 1)
   		motor[arm] = 127;

  	//Claw controls
   	if (vexRT[Btn6D] == 1 || vexRT[Btn6DXmtr2] == 1)
    	motor[claw] = 127;
   	else if (vexRT[Btn6U] == 1 || vexRT[Btn6UXmtr2] == 1)
   		motor[claw] = 127;
	}
}
