#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           armMotor,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           clawMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           backRight,     tmotorVex269_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port4,           backLeft,      tmotorVex269_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port5,           frontRight,    tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           frontLeft,     tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

string motors[] = {frontRight, frontLeft, backRight, backLeft};

//void ForwardForDistance(int speed, float targetDistance) //The arguments are sorted alphabetically. Make speed negative to reverse and change the wait to abs to make sure it works
//{
//	//float rotations = targetDistance / circumference; On torque mode (stock), there are 627 counts to a revolution, high speed there is 392, and turbo speed has 261
//	//float degrees = rotations * 360;
//	//float encoderCounts = degrees * 4;	// 24 / 18.375 is 1.30612244898

//	//Auto-correction
//	//while(nMotorEncoder[frontRight] < encoderCounts && nMotorEncoder[frontLeft] < encoderCounts)
//	//{
//	//	if (nMotorEncoder[frontRight] > nMotorEncoder[frontLeft])
//	//	{
//	//		motor[frontRight] = speed / 2;
//	//		motor[backRight] = speed / 2;
//	//	}
//	//	else if(nMotorEncoder[frontRight] < nMotorEncoder[frontLeft])
//	//	{
//	//		motor[frontLeft] = speed / 2; // These are negative because we are still turning
//	//		motor[backLeft] = speed / 2;
//	//	}
//	//	else if (nMotorEncoder[frontRight] == nMotorEncoder[frontLeft])
//	//	{
//	//		motor[frontRight] = speed;
//	//		motor[frontLeft] = speed;
//	//		motor[backRight] = speed;
//	//		motor[backLeft] = speed;
//	//	}
//	//}



//	float motorEncoderRight = targetDistance, motorEncoderLeft = targetDistance;	//600 = 1 foot

//	while (nMotorEncoder(frontRight) < motorEncoderRight && nMotorEncoder(frontLeft) < motorEncoderLeft)
//	{
//		motor[frontRight] = speed;
//		motor[frontLeft] = speed;
//		motor[backRight] = speed;
//		motor[backLeft] = speed;
//	}
//}

task main()
{
	while (true)
	{

		// This is the main execution loop for the user control program. Each time through the loop
		// your program should update motor + servo values based on feedback from the joysticks.
		// Based on what wheels are installed, change the program between regular and mecanum wheels

		/*frontRightValue = 0;
		backRightValue = 0;
		frontLeftValue = 0;
		backLeftValue = 0;

		if (abs(vexRT[Ch2]) > 10)
		{
				frontRightValue = vexRT[Ch2];
				backRightValue = vexRT[Ch2];
		}
		if (abs(vexRT[Ch3]) > 10)
		{
				frontLeftValue = vexRT[Ch3];
				backLeftValue = vexRT[Ch3];
		}
		if (abs(vexRT[Ch2Xmtr2]) > 10)
		{
				frontRightValue = vexRT[Ch2Xmtr2];
				backRightValue = vexRT[Ch2Xmtr2];
		}
		if (abs(vexRT[Ch3Xmtr2]) > 10)
		{
				frontLeftValue = vexRT[Ch3Xmtr2];
				backLeftValue = vexRT[Ch3Xmtr2];
		}

		motor[frontRight] = frontRightValue;
		motor[backRight] = backRightValue;
		motor[frontLeft] = frontLeftValue;
		motor[backLeft] = backLeftValue;*/

		// Under here is the code for mecanum wheels
		//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	  int X2 = 0, Y1 = 0, X1 = 0, threshold = 15, armMovement = 0, clawMovement = 0;

    //Create "deadzone" for Y1/Ch3
    if (abs(vexRT[Ch3]) > threshold)
      Y1 = vexRT[Ch3];
    else if (abs(vexRT[Ch3Xmtr2]) > threshold)
    	Y1 = vexRT[Ch3Xmtr2];
    else
      Y1 = 0;
    //Create "deadzone" for X1/Ch4
    if (abs(vexRT[Ch4]) > threshold)
      X1 = vexRT[Ch4];
    else if (abs(vexRT[Ch4Xmtr2]) > threshold)
    	X1 = vexRT[Ch4Xmtr2];
    else
      X1 = 0;
    //Create "deadzone" for X2/Ch1
    if (abs(vexRT[Ch1]) > threshold)
      X2 = vexRT[Ch1];
    else if (abs(vexRT[Ch1Xmtr2]) > threshold)
    	X2 = vexRT[Ch1Xmtr2];
    else
      X2 = 0;

    //Arm Controls
    if (vexRT[Btn5D] == 1 || vexRT[Btn5DXmtr2] == 1)
    	armMovement = 127;
   	else if (vexRT[Btn5U] == 1 || vexRT[Btn5UXmtr2] == 1)
   		armMovement = -127;

  	//Claw controls
   	if (vexRT[Btn6D] == 1 || vexRT[Btn6DXmtr2] == 1)
    	clawMovement = 127;
   	else if (vexRT[Btn6U] == 1 || vexRT[Btn6UXmtr2] == 1)
   		clawMovement = -127;

    //Remote Control Commands
    motor[frontRight] = Y1 - X2 - X1;
    motor[backRight] =  Y1 - X2 + X1;
    motor[frontLeft] = Y1 + X2 + X1;
    motor[backLeft] =  Y1 + X2 - X1;
    motor[armMotor] = armMovement;
    motor[clawMotor] = clawMovement;
	}
}
