#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           armMotor,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           clawMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           backRight,     tmotorVex269_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port4,           backLeft,      tmotorVex269_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port5,           frontRight,    tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           frontLeft,     tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float diameter = 4;
float circumference = diameter * PI;

void Move(float distanceToTravel, int speed)
{
	//Distance of circumference = 360 degrees
	//Distance you want to go / circumference
	//(360 * above ratio) = how many degrees the wheels have to turn

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	int wheelTurns = ((distanceToTravel / circumference) * 360);

	while (abs(SensorValue[rightEncoder]) < wheelTurns && abs(SensorValue[leftEncoder]) < wheelTurns)
	{
		if (abs(SensorValue[rightEncoder]) > abs(SensorValue[leftEncoder]))
		{
			//Slow down the right side
			motor[frontRight] = speed / 2;
			motor[backRight] = speed / 2;
		}
		else if (abs(SensorValue[rightEncoder]) < abs(SensorValue[leftEncoder]))
		{
			//Slow down the left side
			motor[frontLeft] = speed / 2;
			motor[backLeft] = speed / 2;
		}
		else if (SensorValue[rightEncoder] == SensorValue[leftEncoder])
		{
			motor[frontRight] = speed;
			motor[frontLeft] = speed;
			motor[backRight] = speed;
			motor[backLeft] = speed;
		}
	}

	motor[frontRight] = 0;
	motor[frontLeft] = 0;
	motor[backRight] = 0;
	motor[backLeft] = 0;
}

//If we make "direction" a string, C, the absolutely "best" program language, says that "Right" isn't a string... smh
void Turn(float degreesToTurn, char* direction, int speed)
{
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	//Degrees to turn / 90
	//Above ratio * encoder counts from doing a 90 degree point turn = encoder coounts right

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Play around with the below value, 450 does not seem to be perfect...
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//450 is the counts for a 90 degree point turn
	int pointTurn90Counts = 450;
	int encoderCountsRight = (degreesToTurn / 90) * pointTurn90Counts;
	int encoderCountsLeft = -encoderCountsRight;

	while (abs(SensorValue[rightEncoder]) < abs(encoderCountsRight) && abs(SensorValue[leftEncoder]) < abs(encoderCountsLeft))
	{
		if (direction == "Left")
		{
			if (abs(SensorValue[rightEncoder]) > abs(SensorValue[leftEncoder]))
			{
				//Slow down the right side
				motor[frontRight] = speed / 2;
				motor[backRight] = speed / 2;
			}
			else if (abs(SensorValue[rightEncoder]) < abs(SensorValue[leftEncoder]))
			{
				//Slow down the left side
				motor[frontLeft] = -speed / 2;
				motor[backLeft] = -speed / 2;
			}
			else if (SensorValue[rightEncoder] == SensorValue[leftEncoder])
			{
				motor[frontRight] = speed;
				motor[frontLeft] = -speed;
				motor[backRight] = speed;
				motor[backLeft] = -speed;
			}
		}
		else if (direction == "Right")
		{
			if (abs(SensorValue[rightEncoder]) > abs(SensorValue[leftEncoder]))
			{
				//Slow down the right side
				motor[frontRight] = -speed / 2;
				motor[backRight] = -speed / 2;
			}
			else if (abs(SensorValue[rightEncoder]) < abs(SensorValue[leftEncoder]))
			{
				//Slow down the left side
				motor[frontLeft] = speed / 2;
				motor[backLeft] = speed / 2;
			}
			else if (SensorValue[rightEncoder] == SensorValue[leftEncoder])
			{
				motor[frontRight] = -speed;
				motor[frontLeft] = speed;
				motor[backRight] = -speed;
				motor[backLeft] = speed;
			}
		}
	}

	motor[frontRight] = 0;
	motor[frontLeft] = 0;
	motor[backRight] = 0;
	motor[backLeft] = 0;
}

void RotateArm(int degreesToRotate, int speed)
{
	resetMotorEncoder(armMotor);

	//You can clear the timer, but it automatically starts
	clearTimer(T1);

	//Get degreesToRotate / 145
	//Multiply above ratio by armVerticalCounts
	//Move motors until they reach above value
	bool booleanChecks[3];
	int counter = 0;
	bool status = false;
	int armVerticalCounts = 1650;
	int armEncoderCounts = (degreesToRotate / 145) * armVerticalCounts;

	while (!status)
	{
			if (abs(nMotorEncoder(armMotor)) < armEncoderCounts)
				motor[armMotor] = speed;
			else if (abs(nMotorEncoder(armMotor)) < armEncoderCounts - 500)
				motor[armMotor] = speed / 2;
			else if (abs(nMotorEncoder(armMotor)) < armEncoderCounts - 150)
				motor[armMotor] = speed / 4;
			else if (abs(nMotorEncoder(armMotor)) == armEncoderCounts)
				motor[armMotor] = 0;
			else if (abs(nMotorEncoder(armMotor)) > armEncoderCounts + 150)
				motor[armMotor] = -speed / 4;
			else if (abs(nMotorEncoder(armMotor)) > armEncoderCounts + 500)
				motor[armMotor] = -speed / 2;
			else if (abs(nMotorEncoder(armMotor)) > armEncoderCounts)
					motor[armMotor] = -speed;

		if (time1[T1] % 200 == 0)
		{
			if (counter == 3)
			{
				//If all the check booleans equal the same
				if (booleanChecks[0] == booleanChecks[1] == booleanChecks[2] && booleanChecks[0] == true)
					status = true;
				else
					//Reset counter if we have reached the final check and failed it
					counter = 0;
			}
			else if (abs(nMotorEncoder(armMotor)) == armEncoderCounts)
			{
				booleanChecks[counter] = true;
				counter++;
			}
			else if (abs(nMotorEncoder(armMotor)) != armEncoderCounts)
			{
				booleanChecks[counter] = false;
				counter++;
			}
		}
	}
	motor[armMotor] = 0;
}

void RotateClaw(int degreesToRotate, int speed)
{
	resetMotorEncoder(clawMotor);

	clearTimer(T1);

	//Get degreesToRotate / 160
	//Multiply above ratio by clawStraightCounts
	//Move motor until they reach above value
	bool booleanChecks[3];
	int counter = 0;
	bool status = false;
	int clawStraightCounts = 1060;
	int clawEncoderCounts = (degreesToRotate / 160) * clawStraightCounts;

	while (!status)
	{
			if (abs(nMotorEncoder(clawMotor)) < clawEncoderCounts)
				motor[clawMotor] = speed;
			else if (abs(nMotorEncoder(clawMotor)) < clawEncoderCounts - 500)
				motor[clawMotor] = speed / 2;
			else if (abs(nMotorEncoder(clawMotor)) < clawEncoderCounts - 150)
				motor[clawMotor] = speed / 4;
			else if (abs(nMotorEncoder(clawMotor)) == clawEncoderCounts)
				motor[clawMotor] = 0;
			else if (abs(nMotorEncoder(clawMotor)) > clawEncoderCounts + 150)
				motor[clawMotor] = -speed / 4;
			else if (abs(nMotorEncoder(clawMotor)) > clawEncoderCounts + 500)
				motor[clawMotor] = -speed / 2;
			else if (abs(nMotorEncoder(clawMotor)) > clawEncoderCounts)
					motor[clawMotor] = -speed;

		if (time1[T1] % 200 == 0)
		{
			if (counter == 3)
			{
				//If all the check booleans equal the same
				if (booleanChecks[0] == booleanChecks[1] == booleanChecks[2] && booleanChecks[0] == true)
					status = true;
				else
					//Reset counter if we have reached the final check and failed it
					counter = 0;
			}
			else if (abs(nMotorEncoder(clawMotor)) == clawEncoderCounts)
			{
				booleanChecks[counter] = true;
				counter++;
			}
			else if (abs(nMotorEncoder(clawMotor)) != clawEncoderCounts)
			{
				booleanChecks[counter] = false;
				counter++;
			}
		}
	}
	motor[clawMotor] = 0;
}

task main()
{
	RotateClaw(160, -127);
}
