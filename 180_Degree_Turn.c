#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main() {
	// Check this link for encoder help http://www.robotc.net/blog/2012/03/07/programming-with-the-new-vex-integrated-motor-encoders/
	float diameter = 4; // Change this value to the diameter of the wheel. All of these distances should be in inches. Do not change these values on accident!!!
	float circumference = PI * diameter; // This calculates the circumference of the wheel fast and easy!

	// This is the code for the right wheel
	int distanceToGoRight = 17.875; // This is how far we want the robot to go during certain autonomous periods. You can change only this line, nothing else!
	float rotationsRight = distanceToGoRight / circumference;
	int degreesToTurnRight = rotationsRight * 360;
	int encoderCountsRight = degreesToTurnRight * 4; // The encoder counts in quarters of a degree, not a full degree

	// This is the code for the left wheel
	int distanceToGoLeft = -17.875;
	float rotationsLeft = distanceToGoLeft / circumference;
	int degreesLeft = rotationsLeft * 360;
	int encoderCountsLeft = degreesLeft * 4;

	// Reset all the encoder values so we make sure our robot functions properly
	nMotorEncoder[frontRight] = 0;
	nMotorEncoder[frontLeft] = 0;

	// Set the targets for each of the encoders
	nMotorEncoder[frontRight] = encoderCountsRight;
	nMotorEncoder[frontLeft] = encoderCountsLeft;

	if (vexRT[Btn5U] == 1)
	{
		// Run the motors until they have reached their values
		if (nMotorEncoder[frontRight] != runStateIdle && nMotorEncoder[frontLeft] != runStateIdle)
		{
			// We are wating for idk
		}
		else
		{
			motor[frontRight] = 127;
			motor[frontLeft] = -127;
		}
	}
	else
	{
		motor[frontRight] = 0;
		motor[frontLeft] = 0;
	}
}
